## 1. 플로우 기초
~~~
- Flow는 코틀린에서 쓸 수 있는 비동기 스트림
- .collect와 함께써야한다 
- flow는 콜드 스트림이다.(콜트스트림은 요청이 있을때만 값이 전달된다.)
- withTimeoutOrNull방식으로 flow를 취소할 수 있다.
- flow이외에도 flowOf, asFlow등의 플로우 빌더가 있다.
- flowOf는 여러 값을 인자로 전달해 플로우를 만듭니다.
- asFlow는 컬렉션이나 시퀀스를 전달해 플로우를 만들 수 있다.
~~~

## 2. 플로우 연산
~~~
- 플로우에서 map 연산을 통해 데이터를 가공할 수 있습니다.
- filter는 조건에 맞는 요소만 남기는것 필터를 이용해 플로우의 데이터를 가공 할수 있다.
- filterNot을 통해 반대의 값을 얻을 수도 있다.
- transform 연사자를 이용해 조금 더 유연하게 스트림을 변형할 수 있다.
- take연산자는 넣은 값의 개수 만큼의 결과만을 출력한다.
- takeWhile은 take를 이용해서 갯수가 아니라 조건에 맞는것 만을 가지고 용도이다.
- take와 반대역할을 하는 drop이 있다
- drop은 처음 몇개의 결과를 버린다.(dropWhile도 존재한다.)
- reduce는 흔히 map과 reduce로 함께 소개되는 함수형 언어의 오래된 메커니즘이다.
  첫번쨰 값을 결과에 넣은 후 가 값을 가져와 누진적으로 계산합니다.
- 두개의 값을 가지고 와서 가공한후 값을 A에넣고 다음값을 다시B에 넣는 방식
- fold 연산자는 초기값이 있다는 차이만 있습니다.
- count는 종단 연산자이므로 특정값, 결과를 나타내지만
  filter의 중간연산자이기 때문에 .collect를 써야 결과를 볼수 있다.
~~~

## 3. 플로우 컨텍스트
~~~
- 플로우 내에서는 컨텍스트를 바꿀 수 없다
- flowOn은 업스트림과 다운 스트림으로 나눠진다. 업스트림만 flowOn에 있는 컨텍스트로 동작한다
- 실수로 두개를 붙이게되면 default만 인정이 된다.
~~~

## 4. 플로우 버퍼링
~~~
- 버퍼를 사용하면 flow측에 버퍼를 붙이면 collect쪽에 준비와는 상관없이 데이터를 전송한다.
  때문에 지연시간이 줄어든다.
- conflate는 만약 처리보다 빨리 발생한 데이터가 있으면 중간 값들을 누락합니다.
- conflate는 내가처리하고 있는 시간의 중간 값들을 다 버리는것
- collectLatest는 첫번째 값을 받고 실행중에 두번째값이 오면 리셋을 하고 두번째값을 처리한다.
~~~

## 5. 플로우 결합하기
~~~
- zip은 양쪽의 데이터를 한꺼번에 묶는 새로운 데이터를 만들어 냅니다.
- combine은 양쪽의 데이터를 같은 시점에 묶지 않고 한쪽이 갱신되면 새로 묶어 데이터를 만듭니다.
- 용도에 따라서 완전히 짝을 맞추어야 할때는 zip을 써야하고 가장 최신의 데이터가 필요하다라고 생각될때 combin을 사용한다.
~~~








