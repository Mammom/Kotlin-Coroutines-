# Chapter1

## 1. 처음 만나는 코루틴
~~~
- 합의를 해서 나누어 쓰는것(비선점형 멀티 태스킹) -> A가 자기의 리소스를 쓰고 B에게 리소스를 주는것
- 선점형 멀티태스킹(중재자를 두는것 == 운영체제)
- SMP(Symmetric Multiprocessor)와 가시성 -> 락이나 메모리 베리어가 필요할 수 있음
- 데이터를 갱신해도 문제 캐시라인을 통채로 변경해야한다.
- 코루틴은 비동기와 병렬성을 순차적으로 짤수 있다.
- 플로우는 비동기와 병렬성을 스트림의 형태로 쓸수 있다.
~~~

## 2-1. 스코프 빌더
~~~
- Coroutine Scope는 코루틴의 scope를 정의하는 인터페이스입니다.
- Coroutine Context는 코루틴이 앞으로 수행될 방식을 결정
- launch는 새로운 코루틴을 만들어서 다른 코드를 함께 수행하게 하는 코드
- delay는 잠시 쉬는함수 launch와 함께 사용하면 먼저 작동이 가능하다.
- 코루틴의 장점은 양보를 하면서 최선의 결과를 얻을 수 있다.
~~~

## 2-2. 스코프 빌더
~~~
- sleep은 thread가 쉬는 동안에 양보를 안하고 delay는 쉬는 동안에 양보를 한다.
- runBlocking 계층적,구조적이다.
- 부모를 캔슬하면 자식도 캔슬된다.
- suspend 중단 가능한 함수
~~~

## 3. 구조화된 동시성
~~~
- coroutineScope는 오로지 빌더를 호출하기위해 만들어진것
- runbloking은 현제 스레드를 멈추게 하고 기다리게 하는것
- coroutineScope는 다른 누군가가 일을 하려고 하면 일을 하게만든다.
- join이 되어있으면 이시점부터는 기다리고있다.
- 부모코루틴은 자식들이 끝날때까지 기다린다.
~~~

## 4-1. 취소와 타임아웃
~~~
- cancel을 통해서 어떠한 동작을 취소할 수 있다.
- launch는 메인 스레드에서 수행되지만 뒤에 Dispatchers.Default를 
  붙이게 되면 다른 스레드에서 수행되게 됩니다.
- cancel을 넣어도 코드 자체가 이해하지 못하는 코드를 사용하면 취소가 되지않는다.
- cancel뒤에 join을 사용하면 cancel이 될때까지 기다준다.
- cancelAndJoin으로 조금더 쉽게 사용할수 있다.
- isActive 코루틴이 활성화 되어있는지를 볼 수있다.
- isActive를 사용하면 cancel을 이해하는 코드로 바뀌기 때문에 취소가 된다.
~~~

## 4-2. 취소와 타임아웃
~~~
- finally은 파일을 닫아주는 코드
- NonCancellable를 붙이면 취소 불가능한 블록을 만들 수 있다.
- withTimeout를 사용하여 특정시간 이상이 걸리는 일들은 캔슬 할 수 있다.
- withTimeoutOrNull을 이용해서 실패했을때 Null을 리턴한다.
- ?:(앨비스 연산자) 리턴했을때 Null을 다른 값으로 바꿀 수 있다.
~~~

## 5. 서스펜딩 함수
~~~
- aync 키워드를 이용해 동시에 다른 블록을 수행할 수 있다.
- async { name1() } 
  async { name2() }
- await는 결과를 가져온다. join과 같은 기능을 하지만 값도 가지고 올수 있다.
- 잠이 들었다가 깨어나면 사용하는 형식
- 실행시간을 더 빠르게 사용할 수 있다.
- start = CoroutineStart.LAZY는 코루틴이 만들어지지만 수행예약은 되지않는다.
- .start() 를 해주면 큐에 수행예약을 한다.
- 만약 async를 사용하다가 자식이 두개중 하나만이라도 취소된다면 자식과 부모클래스까지
  취소가 된다.
- 다른 형제가 문제가 생겨도 다같인 cancel한다.
~~~

## 6-1. 코루틴 컨텍스트와 디스패처
~~~
- 코루틴의 디스패처 -> Default,IO, Unconfined, newSingleThreadContext
- newSingleThreadContext는 새로운스레드를 쓰는것이기 때문에 이름을 지정해 줄 수 았다.
- Default는 코어 수에 비례하는 스레드 풀에서 수행합니다.
- IO는 코어 수 보다 퓔씬 많은 스레드를 가지는 스레드 풀입니다. IO 작업은 CPU를 덜 소모하기 때문입니다.
- Unconfined는 어디에도 속하지 않는다. 앞으로 어디에서 사용될지 모른다.
- 다른 스레드가 많으 사용되고 있다면은 스레드 할당을 받지 못할수 있기때문에 
  무조건 할당을 받아야 한다면 newSingleThreadContext을 사용한다.
~~~


## 6-2. 코루틴 컨텍스트와 디스패처
~~~
- 여러 코루틴 엘리먼틀르 한번에 사용할 수 있다. + 연산으로 엘리먼트를 합치면 된다.
- coroutinContext[]로 조회 할 수 있다.
- Dispatchers를 이용하여 스레드를 바꿀 수 있다.
~~~

## 7. CEH와 슈퍼바이저 잡
~~~
- GlobalScope은 어디에도 속하지 않는 스코프
- 전역 스코프를 이용하면 코루틴을 쉽게 수행헐 수 있다.
- GlobalScope 어떤 계층에도 속하지 않고 영원히 동작하게 된다는 문제때문에 일반적으로는 잘 쓰여지지않는다.
- CoroutineScope가 권장되는 형식이며 스코프를 만들고 블록을 만든다.
- CEH(CoroutinExceptionHandler)는 람다를 받습니다.
- CEH를 넣으면 오류를 잡을때 용이하다. (scope.launch안에 사용한다.)
- runBlocking은 ceh와 같이 사용할 수는 없다.
- 슈퍼 바이저 잡은 예외에 의한 취소를 아래쪽으로 내려가게 한다.
- 슈퍼 바이저 잡을 하면 예외가 발생했을때 취소를 아래로만 보내기 때문에 다른 자식들에게는 문제가 발생하지 않는다.
- joinAll은 한번에 기다릴 수 있다.
- 코루틴 스코프와 수퍼바이저 잡을 합친듯 한 SupervisorScope가 있습니다.
- SupervisorScope의 특징은 예외가 발생할 곳에 ceh를 붙여야 한다.
~~~







